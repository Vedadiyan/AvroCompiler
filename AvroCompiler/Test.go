/*
   The following code has been automatically generated by the
   AvroCompiler Utility
   ----------------------------------------------------------
   WARNING:    Please DO NOT modify the content of this file.
   ----------------------------------------------------------
   Timestamp:  2022-04-04 11:53:32
   ----------------------------------------------------------
   License:    MIT License
   Author:     Pouya Vedadiyan
*/
package Expedia

import (
	"encoding/base64"
	"github.com/linkedin/goavro"
	"github.com/nats-io/nats.go"
)

type Kind int

const (
	OK Kind = 0
)

func (response Response) Codec() (*goavro.Codec, error) {
	avroSchemaInBase64 := ""
	if value, err := base64.StdEncoding.DecodeString(avroSchemaInBase64); err == nil {
		if codec, err := goavro.NewCodec(string(value)); err == nil {
			return codec, nil
		} else {
			return nil, err
		}
	} else {
		return nil, err
	}
}

type Response struct {
	Results string `avro:"results"`
}

func newResponse(value map[string]any) Response {
	response := Response{}
	if value, ok := value["results"].(string); ok {
		response.Results = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "results")
	}
	return response
}

type Hash string

func (request Request) Codec() (*goavro.Codec, error) {
	avroSchemaInBase64 := "eyJ0eXBlIjoicmVjb3JkIiwibmFtZSI6IlJlcXVlc3QiLCJuYW1lc3BhY2UiOm51bGwsInN5bWJvbHMiOm51bGwsIm9yZGVyIjpudWxsLCJhbGlhc2VzIjpudWxsLCJzaXplIjpudWxsLCJmaWVsZHMiOlt7Im5hbWUiOiJ0ZXN0IiwidHlwZSI6eyJ0eXBlIjoiYXJyYXkiLCJpdGVtcyI6eyJ0eXBlIjoiYXJyYXkiLCJpdGVtcyI6eyJ0eXBlIjoiYXJyYXkiLCJpdGVtcyI6eyJ0eXBlIjoiYXJyYXkiLCJpdGVtcyI6ImludCJ9fX19LCJhbGlhc2VzIjpudWxsfSx7Im5hbWUiOiJraW5kIiwidHlwZSI6eyJ0eXBlIjoiZW51bSIsIm5hbWUiOiJLaW5kIiwic3ltYm9scyI6WyJPSyJdfSwiYWxpYXNlcyI6bnVsbH0seyJuYW1lIjoicmVzcG9uc2UiLCJ0eXBlIjp7InR5cGUiOiJyZWNvcmQiLCJuYW1lIjoiUmVzcG9uc2UiLCJmaWVsZHMiOlt7Im5hbWUiOiJyZXN1bHRzIiwidHlwZSI6InN0cmluZyJ9XX0sImFsaWFzZXMiOm51bGx9LHsibmFtZSI6Imhhc2giLCJ0eXBlIjp7InR5cGUiOiJmaXhlZCIsIm5hbWUiOiJIYXNoIiwic2l6ZSI6MTZ9LCJhbGlhc2VzIjpudWxsfSx7Im5hbWUiOiJudWxsYWJsZUhhc2giLCJ0eXBlIjpbIm51bGwiLCJIYXNoIl0sImFsaWFzZXMiOm51bGx9LHsibmFtZSI6ImZmZiIsInR5cGUiOlsibnVsbCIsInN0cmluZyJdLCJhbGlhc2VzIjpudWxsfSx7Im5hbWUiOiJzdHIiLCJ0eXBlIjp7InR5cGUiOiJtYXAiLCJ2YWx1ZXMiOiJzdHJpbmcifSwiYWxpYXNlcyI6bnVsbH0seyJuYW1lIjoic3RyMiIsInR5cGUiOlt7InR5cGUiOiJtYXAiLCJ2YWx1ZXMiOiJzdHJpbmcifSwiS2luZCJdLCJhbGlhc2VzIjpudWxsfSx7Im5hbWUiOiJzdHIzIiwidHlwZSI6W3sidHlwZSI6Im1hcCIsInZhbHVlcyI6InN0cmluZyJ9LCJLaW5kIiwibnVsbCJdLCJhbGlhc2VzIjpudWxsfSx7Im5hbWUiOiJzdHI0IiwidHlwZSI6WyJudWxsIix7InR5cGUiOiJtYXAiLCJ2YWx1ZXMiOiJzdHJpbmcifV0sImFsaWFzZXMiOm51bGx9XX0="
	if value, err := base64.StdEncoding.DecodeString(avroSchemaInBase64); err == nil {
		if codec, err := goavro.NewCodec(string(value)); err == nil {
			return codec, nil
		} else {
			return nil, err
		}
	} else {
		return nil, err
	}
}

type Request struct {
	Test         [][][][]int    `avro:"test"`
	Kind         Kind           `avro:"kind"`
	Response     Response       `avro:"response"`
	Hash         Hash           `avro:"hash"`
	NullableHash any            `avro:"nullableHash"`
	Fff          any            `avro:"fff"`
	Str          map[string]any `avro:"str"`
	Str2         any            `avro:"str2"`
	Str3         any            `avro:"str3"`
	Str4         any            `avro:"str4"`
}

func newRequest(value map[string]any) Request {
	request := Request{}
	if value, ok := value["test"].([]any); ok {
		tmp0 := make([][][][]int, len(value))
		for index, value := range value {
			if value, ok := value.([]any); ok {
				tmp1 := make([][][]int, len(value))
				for index, value := range value {
					if value, ok := value.([]any); ok {
						tmp2 := make([][]int, len(value))
						for index, value := range value {
							if value, ok := value.([]any); ok {
								tmp3 := make([]int, len(value))
								for index, value := range value {
									if value, ok := value.(int); ok {
										tmp3[index] = value
									}
								}
								tmp2[index] = tmp3
							}
						}
						tmp1[index] = tmp2
					}
				}
				tmp0[index] = tmp1
			}
		}
		request.Test = tmp0
	}
	if value, ok := value["kind"].(Kind); ok {
		request.Kind = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "kind")
	}
	if value, ok := value["response"].(Response); ok {
		request.Response = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "response")
	}
	if value, ok := value["hash"].(Hash); ok {
		request.Hash = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "hash")
	}
	if value, ok := value["nullableHash"].(any); ok {
		request.NullableHash = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "nullableHash")
	}
	if value, ok := value["fff"].(any); ok {
		request.Fff = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "fff")
	}
	if value, ok := value["str"].(map[string]any); ok {
		request.Str = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "str")
	}
	if value, ok := value["str2"].(any); ok {
		request.Str2 = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "str2")
	}
	if value, ok := value["str3"].(any); ok {
		request.Str3 = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "str3")
	}
	if value, ok := value["str4"].(any); ok {
		request.Str4 = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "str4")
	}
	return request
}
