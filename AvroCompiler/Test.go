/*
   The following code has been automatically generated by the
   AvroCompiler Utility
   ----------------------------------------------------------
   WARNING:    Please DO NOT modify the content of this file.
   ----------------------------------------------------------
   Timestamp:  2022-04-04 14:41:17
   ----------------------------------------------------------
   License:    MIT License
   Author:     Pouya Vedadiyan
*/

package Expedia

import (
	"encoding/base64"

	"github.com/linkedin/goavro"
	"github.com/nats-io/nats.go"
)

type Kind2 int

const (
	OK2 Kind2 = 0
)

type Kind int

const (
	OK Kind = 0
)

type Response struct {
	Results string `avro:"results"`
}

func newResponse(value map[string]any) Response {
	response := Response{}

	if value, ok := value["results"].(string); ok {
		response.Results = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "results")
	}

	return response
}

type Hash string
type Request struct {
	Test         [][][][]int    `avro:"test"`
	Kind         Kind           `avro:"kind"`
	Kind2        Kind2          `avro:"kind2"`
	Response     Response       `avro:"response"`
	Hash         Hash           `avro:"hash"`
	NullableHash *Hash          `avro:"nullableHash"`
	Fff          *string        `avro:"fff"`
	Str          map[string]any `avro:"str"`
	Str2         any            `avro:"str2"`
	Str3         any            `avro:"str3"`
	Str4         any            `avro:"str4"`
}

func newRequest(value map[string]any) Request {
	request := Request{}

	if value, ok := value["test"].([]any); ok {
		tmp0 := make([][][][]int, len(value))
		for index, value := range value {

			if value, ok := value.([]any); ok {
				tmp1 := make([][][]int, len(value))
				for index, value := range value {

					if value, ok := value.([]any); ok {
						tmp2 := make([][]int, len(value))
						for index, value := range value {

							if value, ok := value.([]any); ok {
								tmp3 := make([]int, len(value))
								for index, value := range value {
									if value, ok := value.(int); ok {

										tmp3[index] = value

									}
								}

								tmp2[index] = tmp3

							}

						}

						tmp1[index] = tmp2

					}

				}

				tmp0[index] = tmp1

			}

		}
		request.Test = tmp0
	}

	if value, ok := value["kind"].(Kind); ok {
		request.Kind = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "kind")
	}

	if value, ok := value["kind2"].(Kind2); ok {
		request.Kind2 = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "kind2")
	}

	if value, ok := value["response"].(Response); ok {
		request.Response = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "response")
	}

	if value, ok := value["hash"].(Hash); ok {
		request.Hash = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "hash")
	}

	if value, ok := value["nullableHash"].(*Hash); ok {
		request.NullableHash = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "nullableHash")
	}

	if value, ok := value["fff"].(*string); ok {
		request.Fff = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "fff")
	}

	if value, ok := value["str"].(map[string]any); ok {
		request.Str = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "str")
	}

	if value, ok := value["str2"].(any); ok {
		request.Str2 = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "str2")
	}

	if value, ok := value["str3"].(any); ok {
		request.Str3 = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "str3")
	}

	if value, ok := value["str4"].(any); ok {
		request.Str4 = value
	} else {
		// fmt.println("WARNING: Type mismatch for", "str4")
	}

	return request
}

func (response Response) Codec() (*goavro.Codec, error) {
	avroSchemaInBase64 := "ew0KICAgICAgICAidHlwZSIgOiAicmVjb3JkIiwNCiAgICAgICAgIm5hbWUiIDogIlJlc3BvbnNlIiwNCiAgICAgICAgImZpZWxkcyIgOiBbIHsNCiAgICAgICAgICAibmFtZSIgOiAicmVzdWx0cyIsDQogICAgICAgICAgInR5cGUiIDogInN0cmluZyINCiAgICAgICAgfSBdDQogICAgICB9"
	if value, err := base64.StdEncoding.DecodeString(avroSchemaInBase64); err == nil {
		if codec, err := goavro.NewCodec(string(value)); err == nil {
			return codec, nil
		} else {
			return nil, err
		}
	} else {
		return nil, err
	}
}

func (request Request) Codec() (*goavro.Codec, error) {
	avroSchemaInBase64 := "eyJ0eXBlIjoicmVjb3JkIiwibmFtZSI6IlJlcXVlc3QiLCJuYW1lc3BhY2UiOm51bGwsInN5bWJvbHMiOm51bGwsIm9yZGVyIjpudWxsLCJhbGlhc2VzIjpudWxsLCJzaXplIjpudWxsLCJmaWVsZHMiOlt7Im5hbWUiOiJ0ZXN0IiwidHlwZSI6eyJ0eXBlIjoiYXJyYXkiLCJpdGVtcyI6eyJ0eXBlIjoiYXJyYXkiLCJpdGVtcyI6eyJ0eXBlIjoiYXJyYXkiLCJpdGVtcyI6eyJ0eXBlIjoiYXJyYXkiLCJpdGVtcyI6ImludCJ9fX19LCJhbGlhc2VzIjpudWxsfSx7Im5hbWUiOiJraW5kIiwidHlwZSI6eyJ0eXBlIjoiZW51bSIsIm5hbWUiOiJLaW5kIiwic3ltYm9scyI6WyJPSyJdfSwiYWxpYXNlcyI6bnVsbH0seyJuYW1lIjoia2luZDIiLCJ0eXBlIjp7InR5cGUiOiJlbnVtIiwibmFtZSI6IktpbmQyIiwic3ltYm9scyI6WyJPSzIiXX0sImFsaWFzZXMiOm51bGx9LHsibmFtZSI6InJlc3BvbnNlIiwidHlwZSI6eyJ0eXBlIjoicmVjb3JkIiwibmFtZSI6IlJlc3BvbnNlIiwiZmllbGRzIjpbeyJuYW1lIjoicmVzdWx0cyIsInR5cGUiOiJzdHJpbmcifV19LCJhbGlhc2VzIjpudWxsfSx7Im5hbWUiOiJoYXNoIiwidHlwZSI6eyJ0eXBlIjoiZml4ZWQiLCJuYW1lIjoiSGFzaCIsInNpemUiOjE2fSwiYWxpYXNlcyI6bnVsbH0seyJuYW1lIjoibnVsbGFibGVIYXNoIiwidHlwZSI6WyJudWxsIiwiSGFzaCJdLCJhbGlhc2VzIjpudWxsfSx7Im5hbWUiOiJmZmYiLCJ0eXBlIjpbIm51bGwiLCJzdHJpbmciXSwiYWxpYXNlcyI6bnVsbH0seyJuYW1lIjoic3RyIiwidHlwZSI6eyJ0eXBlIjoibWFwIiwidmFsdWVzIjoic3RyaW5nIn0sImFsaWFzZXMiOm51bGx9LHsibmFtZSI6InN0cjIiLCJ0eXBlIjpbeyJ0eXBlIjoibWFwIiwidmFsdWVzIjoic3RyaW5nIn0sIktpbmQiXSwiYWxpYXNlcyI6bnVsbH0seyJuYW1lIjoic3RyMyIsInR5cGUiOlt7InR5cGUiOiJtYXAiLCJ2YWx1ZXMiOiJzdHJpbmcifSwiS2luZCIsIm51bGwiXSwiYWxpYXNlcyI6bnVsbH0seyJuYW1lIjoic3RyNCIsInR5cGUiOlsibnVsbCIseyJ0eXBlIjoibWFwIiwidmFsdWVzIjoic3RyaW5nIn1dLCJhbGlhc2VzIjpudWxsfV19"
	if value, err := base64.StdEncoding.DecodeString(avroSchemaInBase64); err == nil {
		if codec, err := goavro.NewCodec(string(value)); err == nil {
			return codec, nil
		} else {
			return nil, err
		}
	} else {
		return nil, err
	}
}
